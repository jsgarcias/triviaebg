"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _objectPath = _interopRequireDefault(require("object-path"));

/* eslint-disable class-methods-use-this */
var config = require('../res/config.json');

var InstantRemixing = /*#__PURE__*/function () {
  function InstantRemixing() {
    (0, _classCallCheck2["default"])(this, InstantRemixing);
    this.listeners = [];
    this.resolvedConfig = config; // Instant remixes inject VCC mutations into published apps using the
    // `window.KOJI_OVERRIDES` variable. If that variable is present when this
    // class is instantiated, merge the values present in that object with
    // the config file that is present on disk.

    if (window.KOJI_OVERRIDES && window.KOJI_OVERRIDES.overrides) {
      this.resolvedConfig = (0, _deepmerge["default"])(this.resolvedConfig, window.KOJI_OVERRIDES.overrides, {
        arrayMerge: function arrayMerge(dest, source) {
          return source;
        }
      });
    }

    this.isRemixing = false;
    this.editorAttributes = {};
    this.remixListeners = [];
    this.activePath = null;
    this.activePathListeners = [];
    this.currentState = null;
    this.currentStateListeners = [];
    this.registerListeners();
  } // Get a value from the resolved Koji config, including any overrides from the
  // global space, or processed changes from our event listeners. `path` is an
  // array of keys pointing to the desired value


  (0, _createClass2["default"])(InstantRemixing, [{
    key: "get",
    value: function get(path) {
      var pointer = this.resolvedConfig;

      for (var i = 0; i < path.length; i += 1) {
        pointer = pointer[path[i]];
      }

      return pointer;
    } // Add a listener that is triggered when we receive changes to VCC files
    // from window events. `callback` is a function like (path, newValue) => {},
    // where path is an array of keys pointing to the changed value.

  }, {
    key: "onValueChanged",
    value: function onValueChanged(callback) {
      this.listeners.push(callback);
    } // Handler to receive events when we figure out if we're being remixed or not,
    // to allow the app to present itself differently when being remixed

  }, {
    key: "onSetRemixing",
    value: function onSetRemixing(callback) {
      this.remixListeners.push(callback);
    } // Handler to receive events when the current VCC changes

  }, {
    key: "onSetActivePath",
    value: function onSetActivePath(callback) {
      this.activePathListeners.push(callback);
    } // Handler to receive events when the user changes the app's state

  }, {
    key: "onSetCurrentState",
    value: function onSetCurrentState(callback) {
      this.currentStateListeners.push(callback);
    } // Ask the Koji editor to present a control at a keypath

  }, {
    key: "onPresentControl",
    value: function onPresentControl(path) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (window.parent) {
        window.parent.postMessage({
          _type: 'KojiPreview.PresentControl',
          path: path,
          attributes: attributes
        }, '*');
      }
    } // Explicitly set a value for a VCC at a path

  }, {
    key: "onSetValue",
    value: function onSetValue(path, newValue) {
      if (window.parent) {
        window.parent.postMessage({
          _type: 'KojiPreview.SetValue',
          path: path,
          newValue: newValue
        }, '*');
      }
    } // Required to notify parent containers that the window is ready to receive
    // events over the wire. Parent is responsible for queueing events and
    // redispatching them if the app is not ready to receive them.

  }, {
    key: "ready",
    value: function ready() {
      if (window.parent) {
        window.parent.postMessage({
          _type: 'KojiPreview.Ready'
        }, '*');
      }
    } // (private) Register event listeners for changes

  }, {
    key: "registerListeners",
    value: function registerListeners() {
      var _this = this;

      // Coming in from an iframe (instant remix)
      window.addEventListener('message', function (_ref) {
        var data = _ref.data;
        var event = data.event; // Handle initialization event

        if (event === 'KojiPreview.IsRemixing') {
          var isRemixing = data.isRemixing,
              editorAttributes = data.editorAttributes;

          try {
            _this.isRemixing = isRemixing;
            _this.editorAttributes = editorAttributes || {};

            _this.remixListeners.forEach(function (callback) {
              callback(isRemixing, editorAttributes || {});
            });
          } catch (err) {
            console.log(err);
          }
        } // Handle value change events


        if (event === 'KojiPreview.DidChangeVcc') {
          try {
            var path = data.path,
                newValue = data.newValue;

            _this.emitChange(path, newValue);
          } catch (err) {
            console.log(err);
          }
        } // Handle active path changes


        if (event === 'KojiPreview.DidSetActivePath') {
          try {
            var _path = data.path;
            _this.activePath = _path;

            _this.activePathListeners.forEach(function (callback) {
              callback(_path);
            });
          } catch (err) {
            console.log(err);
          }
        } // Handle current state changes


        if (event === 'KojiPreview.DidSetCurrentState') {
          try {
            var state = data.state;
            _this.currentState = state;

            _this.currentStateListeners.forEach(function (callback) {
              callback(state);
            });
          } catch (err) {
            console.log(err);
          }
        }
      }); // Coming in from a websocket (live preview)

      window.addEventListener('KojiPreview.DidChangeVcc', function (e) {
        try {
          var _e$detail = e.detail,
              path = _e$detail.path,
              newValue = _e$detail.newValue;

          _this.emitChange(path, newValue);
        } catch (err) {
          console.log(err);
        }
      });
    } // (private) Update our local version of the config, and dispatch change
    // events to any callbacks we have registered

  }, {
    key: "emitChange",
    value: function emitChange(path, newValue) {
      _objectPath["default"].set(this.resolvedConfig, path.join('.'), newValue);

      this.listeners.forEach(function (callback) {
        callback(path, newValue);
      });
    }
  }]);
  return InstantRemixing;
}();

exports["default"] = InstantRemixing;