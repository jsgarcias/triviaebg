"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = compile;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _lodash = _interopRequireDefault(require("lodash"));

var _this = void 0;

function toSafeString(textToConvert) {
  // identifiers in javaScript/ts:
  // First character: a-zA-Z | _ | $
  // Rest: a-zA-Z | _ | $ | 0-9
  return (// remove accents, umlauts, ... by their basic latin letters
    _lodash["default"].deburr(textToConvert) // replace chars which are not valid for identifiers with whitespace
    .replace(/(^\s*[^a-zA-Z_$])|([^a-zA-Z_$\d])/g, ' ') // remove remaining whitespace
    .replace(/\s/g, '')
  );
}

function jsonWalker(json, key, level, parentType) {
  var that = this; // Wrap all key/item pairs within an object into a block

  var types = Object.entries(json).map(function (pair) {
    var key = pair[0];
    var value = pair[1];
    var env = {
      key: key,
      level: level,
      value: value
    };

    if ((0, _typeof2["default"])(json[key]) === 'object' || json[key] instanceof Array) {
      return that.lineDecorator.call(env, that.innerWalker(json[key], key, level + 1), parentType);
    }

    if (typeof json[key] === 'string' || typeof json[key] === 'boolean' || typeof json[key] === 'number') {
      return that.lineDecorator.call(env, "".concat((0, _typeof2["default"])(json[key])), parentType);
    }

    throw new Error("[@withkoji/vcc] Config definitions parser - Malformed object data for ID ".concat(key, " & value ").concat(value));
  }); // Output all pairs into one, wrapped with the appropriate key and bracket/brace

  return that.blockDecorator.call({
    key: key,
    level: level
  }, types, parentType);
}

var createJsonDefinitions = function createJsonDefinitions(json) {
  function innerWalker(json, key, level) {
    var _this2 = this;

    // If this is an array, we will build the internals without a key, since arrays don't need them
    var jsonType = 'object';

    if (Array.isArray(json)) {
      jsonType = 'array';
    }

    return jsonWalker.bind({
      lineDecorator: function lineDecorator(type, parentType) {
        var valueType = (0, _typeof2["default"])(_this2.value);
        var lineContent = parentType === 'object' ? "".concat(toSafeString(_this2.key), ": ").concat(type) : "".concat(type);
        var comment = valueType === 'string' || valueType === 'boolean' || valueType === 'number' ? "".concat('  '.repeat(_this2.level + 1), "/** Value: ").concat(_this2.value, ", Type: ").concat(valueType, " */\n") : '';
        return "".concat(comment).concat('  '.repeat(_this2.level + 1)).concat(lineContent);
      },
      innerWalker: innerWalker,
      blockDecorator: function blockDecorator(types, parentType) {
        if (parentType === 'object') {
          return "{\n".concat(types.join(',\n'), "\n").concat('  '.repeat(_this2.level), "}");
        }

        return "[\n".concat(types.join(',\n'), "\n").concat('  '.repeat(_this2.level), "]");
      }
    })(json, key, level, jsonType);
  }

  return jsonWalker.bind({
    lineDecorator: function lineDecorator(type, parentType) {
      if (_this.key === '@@editor') {
        return '';
      }

      var valueType = (0, _typeof2["default"])(_this.value);
      var lineContent = parentType === 'object' ? "".concat(toSafeString(_this.key), ": ").concat(type, ";") : "".concat(type, ",");
      var comment = valueType === 'string' || valueType === 'boolean' || valueType === 'number' ? "  /** Value: ".concat(_this.value, ", Type: ").concat(valueType, " */\n") : '';
      return "".concat(comment, "  ").concat(lineContent);
    },
    innerWalker: innerWalker,
    blockDecorator: function blockDecorator(types) {
      return types.join('\n');
    }
  })(json, null, 0, 'object');
};

function compile(json) {
  return createJsonDefinitions(json);
}